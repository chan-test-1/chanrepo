-- 복습
------------------------------
일반함수
function 함수명(){
    ...
}
------------------------------
화살표함수
const 함수명 = () => {
    ...
}
------------------------------
즉시실행함수
(function)()
------------------------------

콜백함수
function a(num){

}

function b(fn) => {
  ... 
  a(123)
}

b(a)

------------------------------

객체
* 정의에 집중하는 것이 아님.
* 문제를 해결할 때 언제 이 객체를 떠올릴 수 있는가.
=> 특정 집단에서 key(고유한)를 이용하여 원하는 값을 찾을 때

const seongyong ={ 
    height : 190,
    age : 20
}

seongyong.age (자동완성!!)

** JSON **
자바스크립트 객체 표현식
서버에 데이터를 응답을 받았을 때 주로 받게될 데이터의 형태가 JSON
------------------------------



** 배열 **

객체는 하나의 주제로 공통된 프로퍼티의 집합이고
배열은 여러개의 항목 목록이 들어간다.
배열은 순서가 있다! (정렬된 값의 집합)

게시글의 정보는 객체로 묶을 수 있다. -> const post = {}
숫자 1부터 5까지 객체로 의미부여 하면서 넣을 수 있나?      
const numberList = { 1:1, 2:2, 3:3 , 4:4, 5:5} ? 넣을수있긴 한데 이상하지?
그냥 배열로 넣는다. 

const numberArray = [1,2,3,4,5]

1. 순서가 필요하고! prev(이전), next(다음) 기능이 필요할 때 
2. 순회 가능하다! (순서대로 반복이 가능하다!) = 순서를 보장한다!

객체 (하나의 공통된 주제로 특정 사물의 정보를 나타내는 집합)
배열 (순서를 보장하는 데이터의 집합) - 어떤것이든 들어갈수있다.객체를 넣을 수도있다.

const post = {}
const postList = [post, post, post, post]

const seongyong = {
    age : 20, 
    height: 190
}

seongyong.age 

const seongyongArr = [20, 190]
seongyongArr[0]

배열은 순서(index)로 원하는 값에 접근
객체는 Key로 원하는 값에 접근.
명확한 네이밍이 일표한경우 객체, 아니면 배열.

백엔드가 주는 데이터가 모두 배열이 많다 ! 배열안에 객체 !

이배열때문에 프론트엔드 백엔드가 많이 싸운다고한다. 배열에 계산을해서 백엔드가 넣어줄거냐. 데이터만 보내주면 프론트에서 계산해서 배열을 만들거냐 등등.. 
백엔드는 서버과부하걸린다 프론트는 화면 느려진다. 

자바같은건 배열 선언이 정적이지만 List<int>
자바스크립트는 어떤것이든 넣을 수 있다 const post = {1, "2", {}}

arr.js

------------------------------------------------

// 자바스크립트는 ES6(2015), ES2022, ES2024 도 있고 버전업을 계속 하고있다. ES6 때 많은변화가 일어났고
// 취업할때에 ES6 면접. 쓸줄아냐? const , let 차이 알어? 등등 .
// ES6 를 도입한건 2018, 2020 얼마 되지않았다 .
// 취업을 하면 전자정부프레임워크 규약 (정부에서 돈을내고 프로젝트를 만들었네?)
// 전자정부프레임워크는 쓸수있는걸 제한해놨고. 전자정부도입한곳은 아직도 ES6 전 문법을 쓰는곳이 엄청 많다.
// var 로 도배되어있는 회사도 엄청많다. (var를 쓰면.. 휴먼에러 : 컴퓨터는 죄가없죠 제가멍청해서그렇습니다.)
// 7,8년, 10년 이상 차 공공기관 개발자가 REACT가 뭐에요? 라고 묻는사람도 많다.



//배열을 다룰 때에 가장 많이 사용되는 문법 리스트
/*
indexOf
includes
join
concat
reverse
splice
slice
map
filter
sort
find
every
some
findIndex
reduce
flat
flatMap
*/


------------------------------------------------


indexOf(value)
    배열 요소 중에 특정 값의 요소를 검색하여 현재 위치(인덱스)를 반환

includes(value)
    배열 안에 파라미터로 전달 된 요소 존재하면 true, false

concat(arr)
    서로 다른 두 배열을 하나로 합친 새로운 배열을 반환

const arr = []; 
arr.push()

arr.js 에서 const arr 을 push 했을 떄 const인데 값이 변경이 되었지? 설명해줄게.

참조 객체 
    객체는 값을 추가할 수도 있고 제거할 수도 있다. 배열도 객체이다.
    const로 값을 선언했을 때 값 변경이 불가능한데 어떻게 추가, 삭제?
    동적인 메모리 할당 (Heap), 원시적인건 callStack에 바로할당. 
    배열과 객체는 Heap 에 저장되고 callStack에 있는 const a 가 Heap 에 있는 주소값을 저장한다.
    const 가 바라보는 주소값은 변경되지 않으므로 Heap에있는 배열과 객체의 주소안에있는 값들은 변경할 수 있다.
    
    c(저급언어)는 주소를 참조하는 pointer 가있고 참조했으면 제거하는 문법도 있다.
    java, javaScript (고급언어) 는 불변성 때문에 값을 할당했으면 바뀌지않는다. 재할당! 변수 5에 담긴 값을 6으로 바꾸면 5를 (가비지컬렉터(쓰레기수거)) 를 해주는 기능이있다.
    
    const menu ={
        떡볶이 : 2000
    }
    menu["순대"] = 2000;  // 추가
    delete menu["떡볶이"] // 삭제

원시 값(숫자,문자) -> 실제 변수에 할당 

그래서 참조주소를 변경할 떄 concat을 쓰는경우도있다.  arr.concat([1]) // 참조주소가 바뀐 새로운 배열을 반환.
react는 값이 변경되어야 재랜더링을 하는데 
arr.push 로하면 참조주소가 바뀌지않으므로 바뀐걸로 인식안한다.

ex) 
    const arr =[1,2,3]
    const arr2 =[4,5,6]

    const newConcatArray =  arr.concat(arr2)  // [1,2,3,4,5,6] 

    새로운 주소 생성.

    arr,arr2 는 그대로있다.

------------------------------------

join + split(배열 관계된건 아님, string)     // join 배열을 문자로 , split 문자를 배열로

-join-
배열안의 모든 요소를 이어서 문자열로 반환

const phoneNumberArr = [010, 1234, 1234]

"010-1234-1234" // 배열을 문자로 
phoneNumberArr.join('-')

phoneNumberArr.join()
"01012341234"

-split-
"010-1234-1234".split('-') // 하이푼 기준으로 짤라서 배열을 만듬.
["010", "1234", "1234"]


------------------------------------

slice
    배열의 특정 부분에 접근할 때
    const arr = [1,2,3,4,5] 
    arr.slice(startIndex, endIndex직전까지)
    arr.slice(2, 4) // [3,4]
    arr.slice(2) [3,4,5]

    const sliceData = arr.slice(-1, startIndex 직전까지)  // 뒤에서부터 가져오고 싶을 때. -1은 젤 뒤라고 생각해라.
    
splice
    원본 배열 훼손
    특정 구간을 제거하거나 대체할 때.

    arr.splice(startIndex, count, item1, item2, ...) 

    startIndex  , count : 첨부터 몇개까지 없앨 꺼냐.
    arr.splice(1,3)  // 1번부터 3번까지 제거.
    arr.splice(1,3,'안','녕',하,세,요)  // [1,'안','녕','하','세','요',5]

    


reverse //반전, 뒤집는것.
    원본 배열 훼손
    
    arr.reverse()
    // [5,4,3,2,1]

    //원본은 다른곳에서 쓰고있을 수 있으므로 직접 건들지말구 복사해서 쓴다.         
    const temp_arr = [...arr] //복사본 생성. 얕은복사.
    temp_arr.reverse();

    const temp_arr = arr; 로 하면안된다. 이건 참조(같은주소)라서 원본이 같이 바뀐다.


--------------------------------------

arr02.js